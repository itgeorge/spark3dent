# Agent Testing Failure Report

**Date:** 2026-02-21  
**Timestamp:** 20260221-0130  
**Source:** `agent-qa/agent-testing.md` playbook execution  
**Verdict:** RED

---

## 1. Issue Summary

The first `clients add` command (adding client `dental-pro` via `client-add-1.txt`) crashed with an unhandled `Microsoft.Data.Sqlite.SqliteException` and exit code `-532462766`. The error message indicates:

> SQLite Error 1: 'table "Clients" already exists'

A **retry of the same command succeeded**. All subsequent scenarios (clients list/edit, invoices, error handling, log verification, invoice image verification) completed successfully.

---

## 2. Reproduction Steps

### Failing command

```powershell
dotnet run --project QaHarness -- run --stdin-file client-add-1.txt clients add
```

### Full output (stderr)

```
STDERR: Unhandled exception. Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1: 'table "Clients" already exists'.
   at Microsoft.Data.Sqlite.SqliteException.ThrowExceptionForRC(Int32 rc, sqlite3 db)
   at Microsoft.Data.Sqlite.SqliteDataReader.NextResult()
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteReader(CommandBehavior behavior)
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteReader()
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteNonQuery()
   at System.Data.Common.DbCommand.ExecuteNonQueryAsync(CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Storage.RelationalCommand.ExecuteNonQueryAsync(RelationalCommandParameterObject parameterObject, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Storage.RelationalCommand.ExecuteNonQueryAsync(RelationalCommandParameterObject parameterObject, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Storage.RelationalCommand.ExecuteNonQueryAsync(RelationalCommandParameterObject parameterObject, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationCommandExecutor.ExecuteAsync(...)
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationCommandExecutor.ExecuteAsync(...)
   at Microsoft.EntityFrameworkCore.Storage.RelationalDatabaseCreator.EnsureCreatedAsync(CancellationToken cancellationToken)
   at Cli.CliProgram.SetupDependenciesAsync(Config config, ILogger logger) in C:\Users\itgeorge\spark3dent\Cli\CliProgram.cs:line 64
   at Cli.CliProgram.Main(String[] args) in C:\Users\itgeorge\spark3dent\Cli\CliProgram.cs:line 34
EXIT_CODE: -532462766
```

### Execution context

- **Staging directory:** `C:\Users\itgeorge\AppData\Local\Temp\spark3dent-qa-20260221-012439`
- **Sequence:** Agent ran `help` first, then `clients add` for dental-pro, smile-studio, and zdravko-dent. These commands were invoked in close succession (effectively concurrent or near-concurrent from separate shell invocations).

---

## 3. Investigation

### 3.1 Relevant code

**`Cli/CliProgram.cs`** — `SetupDependenciesAsync` (lines 44–99):

```csharp
static async Task<...> SetupDependenciesAsync(Config config, ILogger logger)
{
    // ...
    await using (var ctx = new AppDbContext(options))
    {
        await ctx.Database.EnsureCreatedAsync();   // line 63
    }
    // ...
}
```

**`Database/AppDbContext.cs`** — model includes `Clients`, `Invoices`, `InvoiceLineItems`, `InvoiceSequence`; no migrations are used in the project (only `EnsureCreated`).

### 3.2 Likely cause: concurrency with EnsureCreated

1. Every CLI command (`help`, `clients add`, `invoices issue`, etc.) runs as a separate process and calls `SetupDependenciesAsync`, which in turn calls `EnsureCreatedAsync` on the same SQLite file.
2. The playbook invokes commands in quick succession, so multiple processes can start concurrently.
3. EF Core's `EnsureCreatedAsync` uses `CREATE TABLE` without `IF NOT EXISTS`. If two processes run it at the same time:
   - One may succeed and create all tables.
   - The other may get "table Clients already exists" when it attempts to create the same table.
4. According to [EF Core behavior](https://learn.microsoft.com/en-us/ef/core/managing-schemas/ensure-created), when tables already exist, schema initialization can fail rather than be silently skipped.

### 3.3 Why the retry succeeded

On the second `clients add` for dental-pro, the database was already fully initialized by other processes, so the process likely saw existing tables. Even so, the exact behavior depends on EF Core's checks; the retry succeeding suggests either:

- No concurrency on retry, or  
- A different code path when tables are already present.

---

## 4. Data for debugging

### 4.1 Automated tests

All 343 automated tests passed (`dotnet test Spark3Dent.sln`).

### 4.2 Scenarios that passed after the retry

- Help, clients list/edit, duplicate nickname error, non-existent client error  
- Invoice issue/list/correct, amount formats, date ordering error  
- All error-handling commands (invalid amounts, dates, missing args, unknown command)  
- Log file (contains `Spark3Dent started`, Info entries; expected errors logged at Error level)  
- Invoice images: 5 PNGs generated; invoices 1, 2, and 5 visually verified with correct content  

### 4.3 Staging directory (preserved)

```
C:\Users\itgeorge\AppData\Local\Temp\spark3dent-qa-20260221-012439
```

Contains: `app/`, `data/spark3dent.db`, `blobs/`, `logs/`, etc. Can be inspected directly.

### 4.4 External references

- [EF Core EnsureCreated docs](https://learn.microsoft.com/en-us/ef/core/managing-schemas/ensure-created)
- [Stack Overflow: "table already exists" with SQLite and EF Core](https://stackoverflow.com/questions/42750991/table-already-exists-exception-when-migrate-db-using-entity-framework-core-and-s)

---

## 5. Suggested fix directions

1. **Serialization of EnsureCreated**  
   Use a file-based or named mutex so only one process initializes the database at a time (e.g. a `*.init.lock` in the data directory).

2. **Idempotent error handling**  
   Catch `SqliteException` with message containing "already exists" and treat it as success (database already initialized).

3. **Migrations instead of EnsureCreated**  
   Use EF Core migrations with idempotent scripts; these typically check or use `IF NOT EXISTS` and are more robust under concurrent startup.

4. **Playbook sequencing**  
   Ensure the agent runs commands sequentially (e.g. wait for `help` to complete before starting `clients add`). This reduces risk but does not fix the underlying race.

---

## 6. Checklist for fix verification

- [ ] Run the full `agent-qa/agent-testing.md` playbook
- [ ] Confirm no unhandled exceptions on any command
- [ ] Optionally: run multiple `clients add` and `help` in parallel to stress-test concurrent initialization
